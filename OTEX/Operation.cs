using System;
using System.Collections.Generic;
using System.Linq;

namespace OTEX
{
    /// <summary>
    /// A single operation.
    /// </summary>
    [Serializable]
    public sealed class Operation
    {
        /////////////////////////////////////////////////////////////////////
        // PROPERTIES
        /////////////////////////////////////////////////////////////////////

        /// <summary>
        /// ID of the client responsible for the change. Normally corresponds to the
        /// ID of another client in the session, but can be Guid.Empty, which is a special
        /// case signifying "this operation was automatically generated by the server
        /// when the file was loaded and cannot be attributed to any client".
        /// (A client will only see this at most once per session, as the very first operation
        /// processed).
        /// </summary>
        public Guid ClientID { get; private set; }

        /// <summary>
        /// Beginning index of the operation.
        /// </summary>
        public int Offset { get; private set; } //TODO: uints?

        /// <summary>
        /// String used for insertions. Null for deletions.
        /// </summary>
        public string Text { get; private set; }

        /// <summary>
        /// Length of character span affected by this operation.
        /// </summary>
        public int Length { get; private set; } //TODO: uints?

        /// <summary>
        /// Is this operation a no-op?
        /// </summary>
        public bool IsNoop
        {
            get { return Length == 0; }
        }

        /// <summary>
        /// Is this operation an insertion?
        /// </summary>
        public bool IsInsertion
        {
            get { return !IsNoop && Text != null; }
        }

        /// <summary>
        /// Is this operation a deletion?
        /// </summary>
        public bool IsDeletion
        {
            get { return !IsNoop && Text == null; }
        }

        /////////////////////////////////////////////////////////////////////
        // CONSTRUCTION/INITIALIZATION/DESTRUCTION
        /////////////////////////////////////////////////////////////////////

        /// <summary>
        /// Create a text insertion operation.
        /// </summary>
        /// <param name="clientID">ID of the node responsible for the change. Cannot be Guid.Empty unless offset is 0
        /// (a special case representing the server's initial load of the document).</param>
        /// <param name="offset">Position in the original text the insert occurred.</param>
        /// <param name="text">Text that was inserted.</param>
        /// <exception cref="ArgumentNullException" />
        /// <exception cref="ArgumentOutOfRangeException" />
        internal Operation(Guid clientID, int offset, string text)
        {
            if (clientID == Guid.Empty && offset != 0)
                throw new ArgumentOutOfRangeException("clientID", "clientID can only be Guid.Empty if it is the first operation (must have offset == 0)");
            ClientID = clientID;
            Offset = offset;
            Length = text.Length;
            Text = text ?? throw new ArgumentNullException("text");
        }

        /// <summary>
        /// Create a text deletion operation.
        /// </summary>
        /// <param name="clientID">ID of the node responsible for the change. Cannot be Guid.Empty.</param>
        /// <param name="offset">Position in the original text the deletion occurred.</param>
        /// <param name="length">Amount of characters that were deleted.</param>
        /// <exception cref="ArgumentOutOfRangeException" />
        internal Operation(Guid clientID, int offset, int length)
        {
            if (clientID == Guid.Empty)
                throw new ArgumentOutOfRangeException("clientID", "clientID cannot be Guid.Empty");
            ClientID = clientID;
            Offset = offset;
            Length = length;
            Text = null;
        }

        /// <summary>
        /// Copy an existing operation.
        /// </summary>
        /// <exception cref="ArgumentNullException" />
        internal Operation(Operation operation)
        {
            if (operation == null)
                throw new ArgumentNullException("operation");
            ClientID = operation.ClientID;
            Offset = operation.Offset;
            Length = operation.Length;
            Text = operation.Text;
        }

        /////////////////////////////////////////////////////////////////////
        // TRANSFORMATIONS
        /////////////////////////////////////////////////////////////////////

        /// <summary>
        /// Perform a symmetric linear transform (SLOT) on two lists of operations (from the same document).
        /// </summary>
        /// <param name="listA">List A</param>
        /// <param name="listB">List B</param>
        /// <exception cref="ArgumentNullException" />
        internal static void SymmetricLinearTransform(IList<Operation> listA, IList<Operation> listB)
        {
            if (listA == null)
                throw new ArgumentNullException("listA");
            if (listB == null)
                throw new ArgumentNullException("listB");

            if (listA.Count == 0 || listB.Count == 0)
                return;

            for (int i = 0; i < listB.Count; i++)
            {
                for (int j = 0; j < listA.Count; j++)
                {
                    Operation listBi = new Operation(listB[i]);
                    listB[i].TransformAgainst(listA[j]);
                    listA[j].TransformAgainst(listBi);
                }
            }
        }

        /// <summary>
        /// Perform a symmetric linear transform (SLOT) on separate sets of documents, matching by key.
        /// </summary>
        /// <param name="documentsA">Document set A</param>
        /// <param name="documentsB">Document set B</param>
        /// <exception cref="ArgumentNullException" />
        internal static void SymmetricLinearTransform<T>(IReadOnlyDictionary<T, List<Operation>> documentsA,
            IReadOnlyDictionary<T, List<Operation>> documentsB)
        {
            if (documentsA == null)
                throw new ArgumentNullException("documentsA");
            if (documentsB == null)
                throw new ArgumentNullException("documentsB");
            foreach (var kvp in documentsA)
            {
                if (documentsB.TryGetValue(kvp.Key, out var docB))
                    SymmetricLinearTransform(kvp.Value, docB);
            }
        }

        internal void TransformAgainst(Operation operation)
        {
            if (operation == null)
                throw new ArgumentNullException("operation");

            if (IsInsertion && operation.IsInsertion)
                IT_II(operation);
            else if (IsInsertion && operation.IsDeletion)
                IT_ID(operation);
            else if (IsDeletion && operation.IsInsertion)
                IT_DI(operation);
            else if (IsDeletion && operation.IsDeletion)
                IT_DD(operation);
        }

        /////////////////////////////////////////////////////////////////////
        // TRANSFORMATIONS (pimpl)
        /////////////////////////////////////////////////////////////////////

        private void IT_II(Operation operation)
        {
            if ((Offset > operation.Offset) || (Offset == operation.Offset && ClientID.CompareTo(operation.ClientID) > 0))
                Offset += operation.Length;
        }

        private void IT_ID(Operation operation)
        {
            if (operation.Length == 0 || Offset <= operation.Offset)
                return;

            if (Offset > (operation.Offset + operation.Length))
                Offset = Offset - operation.Length;
            else if (Offset == (operation.Offset + operation.Length))
                Offset = operation.Offset;
            else
                MakeNoop();
        }

        private void IT_DI(Operation operation)
        {
            if (operation.Offset >= Offset + Length)
                return;

            if (Offset >= operation.Offset)
                Offset += operation.Length;
            else
                Length += operation.Length;
        }

        private void IT_DD(Operation operation)
        {
            if (operation.Length == 0 || operation.Offset >= Offset + Length)
                return;

            if (Offset >= (operation.Offset + operation.Length))
                Offset -= operation.Length;
            else if ((operation.Offset <= Offset) && (Offset + Length <= operation.Offset + operation.Length))
                MakeNoop();
            else if (operation.Offset <= Offset && Offset + Length > operation.Offset + operation.Length)
            {
                var tmpOffset = Offset;
                Offset = operation.Offset;
                Length = (tmpOffset + Length) - (operation.Offset + operation.Length);
            }
            else if (operation.Offset > Offset && operation.Offset + operation.Length >= Offset + Length)
                Length = operation.Offset - Offset;
            else if (operation.Offset > Offset && operation.Offset + operation.Length < Offset + Length)
                Length = Length - operation.Length;
        }

        private void MakeNoop()
        {
            Length = 0;
            Text = null;
        }

        /////////////////////////////////////////////////////////////////////
        // EXECUTION
        /////////////////////////////////////////////////////////////////////

        /// <summary>
        /// Execute an operation on some text, returning the text with the operation applied.
        /// </summary>
        /// <param name="document">The "document" text to execute the operation on.</param>
        /// <exception cref="ArgumentNullException" />
        /// <exception cref="ArgumentOutOfRangeException" />
        /// <returns>The string resulting from applying the operation to the input string.</returns>
        public string Execute(string document)
        {
            if (IsNoop)
                return document;
            if (document == null)
                throw new ArgumentNullException("document");
            if (Offset > document.Length)
                throw new ArgumentOutOfRangeException("offset", "offset cannot be larger than document.length");
            if (Offset < 0)
                throw new ArgumentOutOfRangeException("offset", "offset cannot be negative");

            return IsInsertion ? document.Insert(Offset, Text)
                : (Offset == 0 && Length >= document.Length ? "" : document.Remove(Offset, Length));
        }

        /////////////////////////////////////////////////////////////////////
        // MERGING
        /////////////////////////////////////////////////////////////////////

        /// <summary>
        /// Merge this operation with another one, if possible. Assumes the other operation
        /// is the very next element in a sequence of operations.
        /// </summary>
        /// <param name="op">The other operation.</param>
        /// <returns>True if a merge was successful.</returns>
        /// <exception cref="ArgumentNullException" />
        internal bool Merge(Operation op)
        {
            if (op == null)
                throw new ArgumentNullException("op");
            if (op.IsNoop)
                return true;

            //both operations are insertions, directly back-to-back
            if (IsInsertion && op.IsInsertion && (Offset + Length) == op.Offset)
            {
                Text = Text.Substring(0, Length) + op.Text.Substring(0, op.Length);
                Length += op.Length;
                op.MakeNoop();
                return true;
            }

            //both operations are deletions, directly back-to-back
            if (IsDeletion && op.IsDeletion && Offset == op.Offset)
            {
                Length += op.Length;
                op.MakeNoop();
                return true;
            }

            return false;
        }

        /// <summary>
        /// Merge operations in this list together, if possible.
        /// Assumes the order of operations is linear.
        /// </summary>
        /// <param name="ops">The list of operations to merge.</param>
        /// <returns>True if any merging was successful.</returns>
        /// <exception cref="ArgumentNullException" />
        internal static bool Merge(IList<Operation> ops)
        {
            if (ops == null)
                throw new ArgumentNullException("ops");
            int s = 0;
            bool success = false;
            while (s < (ops.Count - 1))
            {
                if (success |= ops[s].Merge(ops[s + 1]))
                    ops.RemoveAt(s + 1);
                else
                    ++s;
            }
            return success;
        }

        /// <summary>
        /// Merge operations in a document-keyed set of operation lists together, if possible.
        /// Assumes the order of operations per-list is linear.
        /// </summary>
        /// <param name="ops">The set of operations to merge.</param>
        /// <returns>True if any merging was successful.</returns>
        /// <exception cref="ArgumentNullException" />
        internal static bool Merge<T>(IReadOnlyDictionary<T, List<Operation>> ops)
        {
            if (ops == null)
                throw new ArgumentNullException("ops");

            bool success = false;
            foreach (var kvp in ops)
                success |= Merge(kvp.Value);
            return success;
        }

        /////////////////////////////////////////////////////////////////////
        // TRIM
        /////////////////////////////////////////////////////////////////////

        /// <summary>
        /// Removes all no-ops from a set of operations.
        /// </summary>
        /// <param name="ops">The list of operations to trim.</param>
        /// <returns>True if any trimming was successful.</returns>
        /// <exception cref="ArgumentNullException" />
        internal static bool Trim(List<Operation> ops)
        {
            if (ops == null)
                throw new ArgumentNullException("ops");
            return ops.RemoveAll((op) => { return op.IsNoop; }) > 0;
        }

        /// <summary>
        /// Removes all no-ops from all lists in a document-keyed set.
        /// </summary>
        /// <param name="ops">The set of operations to merge.</param>
        /// <returns>True if any merging was successful.</returns>
        /// <exception cref="ArgumentNullException" />
        internal static bool Trim<T>(IReadOnlyDictionary<T, List<Operation>> ops)
        {
            if (ops == null)
                throw new ArgumentNullException("ops");

            bool success = false;
            foreach (var kvp in ops)
                success |= Trim(kvp.Value);
            return success;
        }
    }
}